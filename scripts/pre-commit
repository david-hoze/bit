#!/bin/sh
# Pre-commit hook to check for dangerous patterns in test files
# Run scripts/install-hooks.bat to install this hook

# Dangerous patterns that must not appear in test files
PATTERNS="%CD% %~dp0 %USERPROFILE% %APPDATA% %HOMEDRIVE% %HOMEPATH%"

# Get list of staged .test files
STAGED_TEST_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.test$')

if [ -z "$STAGED_TEST_FILES" ]; then
    # No .test files staged, allow commit
    exit 0
fi

# Check each staged test file for dangerous patterns
VIOLATIONS=""
for FILE in $STAGED_TEST_FILES; do
    LINE_NUM=1
    while IFS= read -r LINE; do
        for PATTERN in $PATTERNS; do
            # Case-insensitive check
            LOWER_LINE=$(echo "$LINE" | tr '[:upper:]' '[:lower:]')
            LOWER_PATTERN=$(echo "$PATTERN" | tr '[:upper:]' '[:lower:]')
            
            if echo "$LOWER_LINE" | grep -q "$LOWER_PATTERN"; then
                VIOLATIONS="${VIOLATIONS}
DANGEROUS PATTERN in ${FILE}:${LINE_NUM}
  Found: ${PATTERN}
  Line:  ${LINE}
"
            fi
        done
        LINE_NUM=$((LINE_NUM + 1))
    done < "$FILE"
done

if [ -n "$VIOLATIONS" ]; then
    echo "========================================"
    echo "PRE-COMMIT HOOK: DANGEROUS PATTERNS FOUND"
    echo "========================================"
    echo "$VIOLATIONS"
    echo ""
    echo "Why dangerous: Windows expands environment variables like %CD% before"
    echo "the command chain executes. If a preceding 'cd' fails, subsequent commands"
    echo "run in the main repo directory, potentially corrupting the development repo."
    echo ""
    echo "Fix: Use relative paths (e.g., ..\\remote_mirror) instead."
    echo ""
    echo "Commit REJECTED. Please fix the violations and try again."
    echo "========================================"
    exit 1
fi

# Check for shelltest format violations (duplicate directives)
FORMAT_VIOLATIONS=""
for FILE in $STAGED_TEST_FILES; do
    # Use awk to check for duplicate directives within test cases
    # Test cases are separated by blank lines
    FORMAT_CHECK=$(awk -v file="$FILE" '
        BEGIN { 
            stdin_count = 0; stdout_count = 0; stderr_count = 0; exit_count = 0
            start_line = 1
        }
        # Blank line or end of file = end of test case
        /^[[:space:]]*$/ || (NR > 1 && prev_blank && /^[[:space:]]*$/) {
            if (stderr_count > 1) {
                print "DUPLICATE >>>2 in " file " near line " start_line " (found " stderr_count " occurrences)"
            }
            if (stdout_count > 1) {
                print "DUPLICATE >>> in " file " near line " start_line " (found " stdout_count " occurrences)"
            }
            if (stdin_count > 1) {
                print "DUPLICATE <<< in " file " near line " start_line " (found " stdin_count " occurrences)"
            }
            if (exit_count > 1) {
                print "DUPLICATE >>>= in " file " near line " start_line " (found " exit_count " occurrences)"
            }
            # Reset counters
            stdin_count = 0; stdout_count = 0; stderr_count = 0; exit_count = 0
            start_line = NR + 1
            prev_blank = 1
            next
        }
        # Skip comment lines
        /^[[:space:]]*#/ { next }
        # Count directives (only at line start or after whitespace)
        /^[[:space:]]*>>>=/ { exit_count++; prev_blank = 0; next }
        /^[[:space:]]*>>>2/ { stderr_count++; prev_blank = 0; next }
        /^[[:space:]]*>>>([^2=]|$)/ { stdout_count++; prev_blank = 0; next }
        /^[[:space:]]*<<</ { stdin_count++; prev_blank = 0; next }
        # Non-blank, non-directive line
        { prev_blank = 0 }
        # Check last test case at end of file
        END {
            if (stderr_count > 1) {
                print "DUPLICATE >>>2 in " file " near line " start_line " (found " stderr_count " occurrences)"
            }
            if (stdout_count > 1) {
                print "DUPLICATE >>> in " file " near line " start_line " (found " stdout_count " occurrences)"
            }
            if (stdin_count > 1) {
                print "DUPLICATE <<< in " file " near line " start_line " (found " stdin_count " occurrences)"
            }
            if (exit_count > 1) {
                print "DUPLICATE >>>= in " file " near line " start_line " (found " exit_count " occurrences)"
            }
        }
    ' "$FILE")
    
    if [ -n "$FORMAT_CHECK" ]; then
        FORMAT_VIOLATIONS="${FORMAT_VIOLATIONS}${FORMAT_CHECK}
"
    fi
done

if [ -n "$FORMAT_VIOLATIONS" ]; then
    echo "========================================"
    echo "PRE-COMMIT HOOK: SHELLTEST FORMAT ERRORS"
    echo "========================================"
    echo "$FORMAT_VIOLATIONS"
    echo ""
    echo "Why this matters: Shelltest Format 3 allows only ONE of each directive"
    echo "(<<<, >>>, >>>2, >>>=) per test case. Multiple directives cause parse"
    echo "errors that prevent the test from running at all."
    echo ""
    echo "Fix: Combine expectations into a single directive with a regex pattern."
    echo "Example: >>>2 /pattern1.*pattern2|pattern2.*pattern1/"
    echo ""
    echo "Commit REJECTED. Please fix the violations and try again."
    echo "========================================"
    exit 1
fi

exit 0
